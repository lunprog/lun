//! Takes the object file from the codegen, and outputs a file with the format
//! corresponding to the orb type.
#![doc(
    html_logo_url = "https://raw.githubusercontent.com/lunprog/lun/main/src/assets/logo_no_bg_black.png"
)]

use std::{
    fs::File,
    io::{self, BufWriter, Write},
    path::{Path, PathBuf},
    process::{Command, Output},
};

use lunc_llib_meta::Lmeta;
use lunc_utils::{BuildOptions, OrbType};
use tar::HeaderMode;
use tempfile::{Builder, NamedTempFile};
use thiserror::Error;

#[derive(Debug, Error)]
pub enum Error {
    #[error("linker error: {0:?}")]
    Linker(Output),
    #[error(transparent)]
    Io(#[from] io::Error),
    #[error(transparent)]
    LlibMeta(#[from] lunc_llib_meta::Error),
}

/// Takes the object file and turns it into the file with appropriate format for
/// the orb type.
#[derive(Debug)]
pub struct Linker {
    /// object content
    objbytes: Vec<u8>,
    /// path of the object file
    objpath: Option<PathBuf>,
    /// output path with the extension
    out: PathBuf,
    /// tempfile, used when we don't want to output .o file.
    ///
    /// # Note
    ///
    /// This is used to keep the temporary file alive, so that the linker can
    /// still find the object file before it being deleted.
    tempfile: Option<NamedTempFile>,
    /// build options
    opts: BuildOptions,
}

impl Linker {
    /// Create a new linker
    pub fn new(
        objbytes: Vec<u8>,
        objpath: Option<PathBuf>,
        out: impl AsRef<Path>,
        opts: BuildOptions,
    ) -> Linker {
        Linker {
            objbytes,
            objpath,
            out: out.as_ref().to_path_buf(),
            tempfile: None,
            opts,
        }
    }

    /// Perform the linkage, this function must be called after
    /// [`Linker::write_obj`] was called.
    pub fn link(&mut self) -> Result<(), Error> {
        match self.opts.orb_type() {
            OrbType::Bin => self.link_bin(),
            OrbType::Llib => self.link_llib(),
        }
    }

    /// Write the object file to the filesystem, either in a temporary file or
    /// in a defined path
    pub fn write_obj(&mut self) -> io::Result<()> {
        if let Some(path) = &self.objpath {
            let mut file = File::create(path)?;

            file.write_all(&self.objbytes)?;

            Ok(())
        } else {
            let mut named_tempfile = Builder::new()
                .prefix("lunc_")
                .suffix(".o")
                .rand_bytes(8)
                .tempfile()?;

            self.objpath = Some(named_tempfile.path().to_path_buf());

            named_tempfile.write_all(&self.objbytes)?;

            self.tempfile = Some(named_tempfile);

            Ok(())
        }
    }

    fn link_bin(&mut self) -> Result<(), Error> {
        let mut cmd = Command::new("cc");

        cmd.arg("-o")
            .arg(&self.out)
            .arg(self.objpath.as_deref().unwrap()) // we set it in write_obj, unwrapping is fine.
            .arg("-nodefaultlibs")
            .arg("-lc")
            .arg("-pie");

        if let Ok(output) = cmd.output()
            && !output.status.success()
        {
            return Err(Error::Linker(output));
        }

        Ok(())
    }

    fn link_llib(&mut self) -> Result<(), Error> {
        let lmeta = Lmeta::new(
            env!("CARGO_PKG_VERSION").to_string(),
            self.opts.target().clone(),
        );

        let lmeta_bytes = lmeta.to_bytes()?;

        let llib_file = File::create(self.out.with_extension("llib"))?;
        let mut llib_w = BufWriter::new(llib_file);

        let mut tar = tar::Builder::new(&mut llib_w);

        tar.mode(HeaderMode::Deterministic);

        tar.append_path_with_name(self.objpath.as_deref().unwrap(), "orb.o")
            .unwrap(); // we set it in write_obj, it's fine

        let mut header = tar::Header::new_gnu();
        header.set_mode(0o600); // <- rw-------

        // append the lmeta
        header.set_size(lmeta_bytes.len() as u64);
        header.set_cksum();

        tar.append_data(&mut header, "orb.lmeta", lmeta_bytes.as_slice())?;

        if cfg!(debug_assertions) {
            let lmeta_txt = format!(
                "\
// This file is automatically @generated by lunc, when the compiler has debug
// assertions. DO NOT modify it.
//
// It is a textual representation of the `orb.lmeta` file.

{}",
                lmeta.to_text()?
            );
            header.set_size(lmeta_txt.len() as u64);
            header.set_cksum();

            tar.append_data(&mut header, "orb.lmeta.ron", lmeta_txt.as_bytes())?;
        }

        tar.finish()?;

        Ok(())
    }
}
