{
    "lexer/char_literal": (
        expected_compiler_out: r#"tokenstream = {
  {
    tt: character 'C';
    loc: 0..3 (fid = 0);
    lexeme: `'C'`;
  },
  {
    tt: character '\0';
    loc: 4..8 (fid = 0);
    lexeme: `'\0'`;
  },
  {
    tt: character '\n';
    loc: 9..13 (fid = 0);
    lexeme: `'\n'`;
  },
  {
    tt: character '\u{c}';
    loc: 14..18 (fid = 0);
    lexeme: `'\f'`;
  },
  {
    tt: character '\t';
    loc: 19..23 (fid = 0);
    lexeme: `'\t'`;
  },
  {
    tt: character '\u{b}';
    loc: 24..28 (fid = 0);
    lexeme: `'\v'`;
  },
  {
    tt: character '\u{7}';
    loc: 29..33 (fid = 0);
    lexeme: `'\a'`;
  },
  {
    tt: character '\u{8}';
    loc: 34..38 (fid = 0);
    lexeme: `'\b'`;
  },
  {
    tt: character '\u{1b}';
    loc: 39..43 (fid = 0);
    lexeme: `'\e'`;
  },
  {
    tt: character '\\';
    loc: 44..48 (fid = 0);
    lexeme: `'\\'`;
  },
  {
    tt: character '@';
    loc: 49..55 (fid = 0);
    lexeme: `'\x40'`;
  },
  {
    tt: character '每';
    loc: 56..60 (fid = 0);
    lexeme: `'每'`;
  },
  {
    tt: character '';
    loc: 61..67 (fid = 0);
    lexeme: `''`;
  },
  {
    tt: end of file;
    loc: 68..69 (fid = 0);
    lexeme: N/A;
  },
}
"#,
        expected_test_out: "",
    ),
    "lexer/integer_literals": (
        expected_compiler_out: "tokenstream = {
  {
    tt: integer '123456789';
    loc: 0..9 (fid = 0);
    lexeme: `123456789`;
  },
  {
    tt: integer '123';
    loc: 29..38 (fid = 0);
    lexeme: `0b1111011`;
  },
  {
    tt: integer '123';
    loc: 39..48 (fid = 0);
    lexeme: `0B1111011`;
  },
  {
    tt: integer '123';
    loc: 67..72 (fid = 0);
    lexeme: `0o173`;
  },
  {
    tt: integer '123';
    loc: 73..78 (fid = 0);
    lexeme: `0O173`;
  },
  {
    tt: integer '123';
    loc: 103..107 (fid = 0);
    lexeme: `0x7b`;
  },
  {
    tt: integer '123';
    loc: 108..112 (fid = 0);
    lexeme: `0X7b`;
  },
  {
    tt: integer '123';
    loc: 113..117 (fid = 0);
    lexeme: `0x7B`;
  },
  {
    tt: integer '123';
    loc: 118..122 (fid = 0);
    lexeme: `0X7B`;
  },
  {
    tt: end of file;
    loc: 123..124 (fid = 0);
    lexeme: N/A;
  },
}
",
        expected_test_out: "",
    ),
    "lexer/kw_idents": (
        expected_compiler_out: "tokenstream = {
  {
    tt: keyword 'and';
    loc: 19..22 (fid = 0);
    lexeme: `and`;
  },
  {
    tt: keyword 'break';
    loc: 23..28 (fid = 0);
    lexeme: `break`;
  },
  {
    tt: keyword 'comptime';
    loc: 29..37 (fid = 0);
    lexeme: `comptime`;
  },
  {
    tt: keyword 'continue';
    loc: 38..46 (fid = 0);
    lexeme: `continue`;
  },
  {
    tt: keyword 'else';
    loc: 47..51 (fid = 0);
    lexeme: `else`;
  },
  {
    tt: keyword 'false';
    loc: 52..57 (fid = 0);
    lexeme: `false`;
  },
  {
    tt: keyword 'for';
    loc: 58..61 (fid = 0);
    lexeme: `for`;
  },
  {
    tt: keyword 'fun';
    loc: 62..65 (fid = 0);
    lexeme: `fun`;
  },
  {
    tt: keyword 'if';
    loc: 66..68 (fid = 0);
    lexeme: `if`;
  },
  {
    tt: keyword 'impl';
    loc: 69..73 (fid = 0);
    lexeme: `impl`;
  },
  {
    tt: keyword 'in';
    loc: 74..76 (fid = 0);
    lexeme: `in`;
  },
  {
    tt: keyword 'let';
    loc: 77..80 (fid = 0);
    lexeme: `let`;
  },
  {
    tt: keyword 'mut';
    loc: 81..84 (fid = 0);
    lexeme: `mut`;
  },
  {
    tt: keyword 'null';
    loc: 85..89 (fid = 0);
    lexeme: `null`;
  },
  {
    tt: keyword 'or';
    loc: 90..92 (fid = 0);
    lexeme: `or`;
  },
  {
    tt: keyword 'pub';
    loc: 93..96 (fid = 0);
    lexeme: `pub`;
  },
  {
    tt: keyword 'return';
    loc: 97..103 (fid = 0);
    lexeme: `return`;
  },
  {
    tt: keyword 'self';
    loc: 104..108 (fid = 0);
    lexeme: `self`;
  },
  {
    tt: keyword 'then';
    loc: 109..113 (fid = 0);
    lexeme: `then`;
  },
  {
    tt: keyword 'trait';
    loc: 114..119 (fid = 0);
    lexeme: `trait`;
  },
  {
    tt: keyword 'true';
    loc: 120..124 (fid = 0);
    lexeme: `true`;
  },
  {
    tt: keyword 'while';
    loc: 125..130 (fid = 0);
    lexeme: `while`;
  },
  {
    tt: ident 'foo';
    loc: 158..161 (fid = 0);
    lexeme: `foo`;
  },
  {
    tt: ident 'bar_baz';
    loc: 162..169 (fid = 0);
    lexeme: `bar_baz`;
  },
  {
    tt: ident 'FooBarBaz';
    loc: 170..179 (fid = 0);
    lexeme: `FooBarBaz`;
  },
  {
    tt: end of file;
    loc: 180..181 (fid = 0);
    lexeme: N/A;
  },
}
",
        expected_test_out: "",
    ),
    "lexer/punctuation": (
        expected_compiler_out: "tokenstream = {
  {
    tt: punctuation LParen;
    loc: 0..1 (fid = 0);
    lexeme: `(`;
  },
  {
    tt: punctuation RParen;
    loc: 2..3 (fid = 0);
    lexeme: `)`;
  },
  {
    tt: punctuation LBracket;
    loc: 4..5 (fid = 0);
    lexeme: `[`;
  },
  {
    tt: punctuation RBracket;
    loc: 6..7 (fid = 0);
    lexeme: `]`;
  },
  {
    tt: punctuation LBrace;
    loc: 8..9 (fid = 0);
    lexeme: `{`;
  },
  {
    tt: punctuation RBrace;
    loc: 10..11 (fid = 0);
    lexeme: `}`;
  },
  {
    tt: punctuation Plus;
    loc: 12..13 (fid = 0);
    lexeme: `+`;
  },
  {
    tt: punctuation Minus;
    loc: 14..15 (fid = 0);
    lexeme: `-`;
  },
  {
    tt: punctuation Star;
    loc: 16..17 (fid = 0);
    lexeme: `*`;
  },
  {
    tt: punctuation Slash;
    loc: 18..19 (fid = 0);
    lexeme: `/`;
  },
  {
    tt: punctuation Colon;
    loc: 20..21 (fid = 0);
    lexeme: `:`;
  },
  {
    tt: punctuation Comma;
    loc: 22..23 (fid = 0);
    lexeme: `,`;
  },
  {
    tt: punctuation Equal;
    loc: 24..25 (fid = 0);
    lexeme: `=`;
  },
  {
    tt: punctuation Equal2;
    loc: 26..28 (fid = 0);
    lexeme: `==`;
  },
  {
    tt: punctuation BangEqual;
    loc: 29..31 (fid = 0);
    lexeme: `!=`;
  },
  {
    tt: punctuation Bang;
    loc: 32..33 (fid = 0);
    lexeme: `!`;
  },
  {
    tt: punctuation LtEqual;
    loc: 34..36 (fid = 0);
    lexeme: `<=`;
  },
  {
    tt: punctuation Lt;
    loc: 37..38 (fid = 0);
    lexeme: `<`;
  },
  {
    tt: punctuation Lt2;
    loc: 39..41 (fid = 0);
    lexeme: `<<`;
  },
  {
    tt: punctuation Gt;
    loc: 42..43 (fid = 0);
    lexeme: `>`;
  },
  {
    tt: punctuation Gt2;
    loc: 44..46 (fid = 0);
    lexeme: `>>`;
  },
  {
    tt: punctuation GtEqual;
    loc: 47..49 (fid = 0);
    lexeme: `>=`;
  },
  {
    tt: punctuation Semicolon;
    loc: 50..51 (fid = 0);
    lexeme: `;`;
  },
  {
    tt: punctuation MinusGt;
    loc: 52..54 (fid = 0);
    lexeme: `->`;
  },
  {
    tt: punctuation Carret;
    loc: 55..56 (fid = 0);
    lexeme: `^`;
  },
  {
    tt: punctuation Ampsand;
    loc: 57..58 (fid = 0);
    lexeme: `&`;
  },
  {
    tt: punctuation Pipe;
    loc: 59..60 (fid = 0);
    lexeme: `|`;
  },
  {
    tt: punctuation Percent;
    loc: 61..62 (fid = 0);
    lexeme: `%`;
  },
  {
    tt: punctuation Dot;
    loc: 63..64 (fid = 0);
    lexeme: `.`;
  },
  {
    tt: punctuation DotStar;
    loc: 65..67 (fid = 0);
    lexeme: `.*`;
  },
  {
    tt: end of file;
    loc: 68..69 (fid = 0);
    lexeme: N/A;
  },
}
",
        expected_test_out: "",
    ),
    "lexer/string_literal": (
        expected_compiler_out: r#"tokenstream = {
  {
    tt: string "Hello, world\n";
    loc: 0..16 (fid = 0);
    lexeme: `"Hello, world\n"`;
  },
  {
    tt: string "\0 \n \r \u{c} \t \u{b} \u{7} \u{8} \u{1b} \\ 每";
    loc: 17..53 (fid = 0);
    lexeme: `"\0 \n \r \f \t \v \a \b \e \\ \xFF"`;
  },
  {
    tt: string "'we can use simple quotes inside a string'";
    loc: 54..98 (fid = 0);
    lexeme: `"'we can use simple quotes inside a string'"`;
  },
  {
    tt: string "string support UTF-8: 每,  etc..";
    loc: 99..137 (fid = 0);
    lexeme: `"string support UTF-8: 每,  etc.."`;
  },
  {
    tt: end of file;
    loc: 138..139 (fid = 0);
    lexeme: N/A;
  },
}
"#,
        expected_test_out: "",
    ),
}
